# Slint + CPAL: архитектура и принципы (конспект)

## Основная модель потоков
- **UI (Slint) = один поток с event loop**. Любые изменения UI/моделей делаются из UI-потока.
- **CPAL = callback-модель**: аудиосистема вызывает ваш callback в **высокоприоритетном audio thread**. Это не «обычный управляемый поток».
- **Связь из worker/audio в UI**: использовать `slint::invoke_from_event_loop(...)` (или аналоги Slint) — это безопасный «вброс задачи» в очередь UI event loop.

## Главное правило real-time аудио
В CPAL callback нельзя рассчитывать на:
- блокировки (mutex/condvar), ожидание каналов, длительные вычисления;
- частые аллокации (`Vec`, `to_vec()`), тяжёлые копии;
- непредсказуемые задержки.

Причина: редкий «спайк» задержки ⇒ **glitch/drop**. Важно не среднее время, а худший случай.

## Data plane vs Control plane
Разделять:
- **Control plane** (команды/настройки): `Start/Pause/Resume/Stop`, смена устройства, уровни gain, и т.п.
- **Data plane** (PCM/аудиоданные и производные метрики).

Команды почти всегда безопасно вести через каналы.

## Рекомендуемый базовый каркас (расширяемый)
### Capture
- **CPAL callback (producer)** пишет PCM в **bounded preallocated структуру**.
- Предпочтительно **SPSC ring buffer** (один producer = callback, один consumer = engine).

### AudioEngine (один consumer)
- Отдельный поток читает из ring buffer.
- Нарезает/агрегирует в блоки (например 10–20 мс) и делает **fan-out**.

### Fan-out к потребителям с разными контрактами
1) **UI визуализация** (обычно *lossy OK*):
   - считать лёгкие метрики (peak/RMS или `levels[32]`), хранить **latest-value** (коалесинг «последнее побеждает»), обновлять UI **30–60 Гц**.
2) **Запись в файл** (*lossless желательно*):
   - отдельный writer thread + буфер/очередь; переполнение = ошибка/stop (иначе потери неизбежны).
3) **Транскрибация**:
   - если требуется **lossless**, нужна либо достаточно большая буферизация, либо spool-to-disk (источник истины) и догоняющая обработка; иначе latency будет расти.

## Throttle и Coalesce
- **Throttle (троттлинг)**: ограничить частоту UI-обновлений (30–60 Гц), независимо от частоты audio callback.
- **Coalesce (коалесинг)**: если пришло много обновлений пока UI занят — не обрабатывать все, а применять **последнее** (latest wins). Это предотвращает рост очередей и «визуализацию из прошлого».
- **Slint-способ throttling**: удобно делать троттлинг прямо в UI-потоке через `slint::Timer` (например, ~60 FPS) и внутри таймера читать `latest` и обновлять свойства/модель. Это уменьшает необходимость часто звать `invoke_from_event_loop`.

Пример:
```rust
slint::Timer::default().start(
    slint::TimerMode::Repeated,
    std::time::Duration::from_millis(16),
    move || {
        // UI thread: читаем latest-value и обновляем UI
        // (latest хранится в thread-safe контейнере: атомики/Mutex/lock-free)
        let levels = latest_levels.load();
        ui.set_audio_levels(levels);
    },
);
```

## Каналы: когда ок, а когда осторожно
- Channels полезны и нормальны **между обычными потоками** (UI↔worker, worker↔writer, commands).
- Опасный паттерн: из CPAL callback делать `send(data.to_vec())`:
  - аллокации/копии + синхронизация;
  - unbounded канал копит хвост ⇒ растёт память и latency;
  - bounded канал может блокировать ⇒ callback ждать нельзя.
- Если всё же канал на data-path:
  - нужен bounded + неблокирующая политика (try_send/try_push),
  - и чёткая стратегия при переполнении (для lossless — это ошибка/stop, для UI — drop).

## «Без потерь» — важная оговорка
Полный lossless возможен только при условии:
- downstream успевает **или** буферов хватает;
- callback **никогда не блокируется**.
Если потребители не успевают и буфер bounded — неизбежен выбор: 
- либо ошибка/останов, 
- либо рост буфера (память/диск),
- либо потери (если разрешены).

## Что рисовать как «гистограмму»
Часто под этим понимают 2 разные вещи:
1) **Level meter** (по времени): RMS/peak (проще, дешёво).
2) **Spectrum bars** (по частотам): FFT + агрегирование бинов (сложнее, обычно не в callback).

## Slint models
- Подход с `VecModel`/`Model` годится для UI.
- Обновлять модель следует **из UI потока** (через `invoke_from_event_loop`).
- Для частых обновлений лучше обновлять не каждый callback, а по таймеру/троттлингу.

## Практическая рекомендация для старта
- Начать с Level meter (RMS/peak) + latest-value + UI 30–60 Гц.
- Сырой PCM: callback → SPSC ring → AudioEngine.
- Запись/транскрибация: отдельные threads, буферизация и явная обработка overload.
